<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="86.98448944091797"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-11 15:04:56 +0000"/><meta name="latitude" content="52.65316435223234"/><meta name="longitude" content="-1.158826765667649"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-13 16:15:36 +0000"/><title>10: Input and Output</title></head><body><div><span style="font-weight: bold;">Memory Mapped I/O</span></div><ul><li><div>Treat I/O device memory as any other type of memory, thus can access instructions like you would any other way.</div></li><li><div>Can access memory of a device directly using languages such as assembly or C.</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Isolated I/O</span></div><ul><li><div>Separate BUS for I/O devices - distinct high-speed memory bus.</div></li><li><div>Accessed via special instructions - no longer able to use the C language to access memory of a device. Need things like assembly.</div></li></ul><div><span style="background-color: rgb(255, 255, 255);" title="Page 18"
				/><img src="10%3A%20Input%20and%20Output.html.resources/F7796902-D521-4030-B765-970E3F41D121.png" height="400" width="1013"/><span style="background-color: rgb(255, 255, 255);" title="Page 18"
			/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Synchronous I/O (Polling or Busy waiting)</span></div><ul><li><div>Code ’spins’ on busy flag awaiting status change - wasteful of processor time.</div></li><li><div>Difficult to interleave useful code as you need an automated mechanism.</div></li><li><div>Good for things that need constant updates.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Asynchronous I/O (Interrupt Driven)</span></div><ul><li><div>Permits other processes to be carried out whilst one process is active.</div></li><li><div>Usually good for processes that take a long amount of time like refreshing things.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Interrupt Service Routine (ISR): </span>Push a copy of all registers so C handler has access to all system states.</div><ul><li><div>One of few places where need to use assembly code - can disable interrupts, push all registers or push just a few registers.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Interrupts</span></div><ul><li><div>If device shares interrupts, there will be no idea which generated the interrupt.</div></li><li><div>After interrupt, must poll each device for data ready or state change.</div></li><li><div>We can group similar devices but that would require more support by processor thus costing more.</div></li></ul><div><br/></div><div><span style="background-color: rgb(255, 255, 255);" title="Page 19"
				/><img src="10%3A%20Input%20and%20Output.html.resources/E2F64951-3539-41E6-B87D-61B22F3F1845.jpg" height="666" width="1052"/><span style="background-color: rgb(255, 255, 255);" title="Page 19"
			/></div><div><br/></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 112px;"/><col style="width: 387px;"/></colgroup><tbody><tr><td colspan="2" style="width: 499px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-weight: bold;">Generalising Interrupts</span></div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Interrupts</span></div></td><td style="width: 387px; padding: 8px; border: 1px solid;"><div>Generated by device attached to specific wire or line - message based requested over intelligent bus <span style="font-weight: bold;">e.g. </span>PCI bus</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Exceptions</span></div></td><td style="width: 387px; padding: 8px; border: 1px solid;"><div>Generated in response to internal processor problem</div></td></tr><tr><td style="width: 112px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Software Interrupts</span></div></td><td style="width: 387px; padding: 8px; border: 1px solid;">Initiated by executing special interrupt or trap instruction.</td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Programmable Interrupt Controller</span></div><ul><li><div>Processor can’t have separate wire to every devices, now use Advanced PIC.</div></li><li><div>Gives priority to most important devices as it orders generated interrupts.</div></li><li><div>We can map PIC interrupts on the interrupt vectors.</div></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 112px;"/><col style="width: 545px;"/></colgroup><tbody><tr><td colspan="2" style="border: 1px solid rgb(204, 204, 204); width: 657px; padding: 8px;"><div style="text-align: center;"><span style="font-weight: bold;">Exceptions Types</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div><span style="font-weight: bold;">Precise</span></div><div>Aight…</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 545px; padding: 8px;">Classic view of interrupts - current instructions complete execution then interrupt service routine is called.</td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div><span style="font-weight: bold;">Imprecise</span></div><div>Lol wut</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 545px; padding: 8px;">Interrupt service routine called, deeply pipelined instruction are not fully complete - hard to recover from due to unknown state.</td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><div><b>Double Fault</b></div><div>Fuk off</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 545px; padding: 8px;"><div>Blue screen of death as there isn’t an ISR</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 112px; padding: 8px;"><b>Triple Faults</b><br/>BITCH WTF</td><td style="border: 1px solid rgb(204, 204, 204); width: 545px; padding: 8px;"><div>Causes machine to restart as it doesn’t have an idea what happened.</div></td></tr></tbody></table><div><br/></div><div><span style="font-weight: bold;">Clocks and Timers</span></div><ul><li><div><span style="font-weight: bold;">Real Time Clock (RTC): </span>Returns encoding of current date.</div></li><li><div><span style="font-weight: bold;">Programmable Interrupt Timer (PIT): </span>Creates periodic event at set / config interval. Used to invoke periodic kernel tasks.</div></li><ul><li><div>If frequency is too low then kernel can seem unresponsive</div></li><li><div>If frequency is too high then OS spends too much time servicing timer.</div></li></ul><li><div>We can maintain queue of things that you want to happen - set +n ms to next event.</div></li><li><div>Circular buffers help improve data throughput - decouple device and processor making it safe.</div></li></ul><div><span style="background-color: rgb(255, 255, 255);" title="Page 20"
				/><img src="10%3A%20Input%20and%20Output.html.resources/910D85B3-9F63-402E-B3CA-7620937DDBCA.jpg" height="280" width="910"/><span style="background-color: rgb(255, 255, 255);" title="Page 20"
			/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Device Drivers</span></div><ul><li><div>Fixed set of functions that you can call <span style="font-weight: bold;">e.g.</span> <span style="font-weight: bold;">read( ), write( ), map( )</span></div></li><li><div>Extensible as you can create new drivers as needed that allow run-time changes.</div></li><li><div>Drivers must be re-entract - can be called again before previous request served and can’t store state in fixed locations. Just in case you have multiple devices.</div></li><li><div>Single-instance (printer) devices must only be accessed by one process.</div></li><li><div>Multi-instance can handle requests from multiple sources.</div></li></ul><div><span style="background-color: rgb(255, 255, 255);" title="Page 20"
				/><img src="10%3A%20Input%20and%20Output.html.resources/D375608E-9DD1-42C7-82E0-FB6F4680E448.jpg" height="608" width="980"/><span style="background-color: rgb(255, 255, 255);" title="Page 20"
			/></div></div><div><br/></div></body></html>