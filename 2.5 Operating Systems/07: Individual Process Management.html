<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.84339904785156"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-10 18:39:10 +0000"/><meta name="latitude" content="52.6397705078125"/><meta name="longitude" content="-1.192643417089529"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-12 13:57:39 +0000"/><title>07: Individual Process Management</title></head><body><div><span style="font-weight: bold;">Java Thread Methods</span></div><div><b><img src="07%3A%20Individual%20Process%20Management.html.resources/41232839-0B38-40BC-AFCA-883EF9CCDBB8.png" height="404" width="914"/><br/></b></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Unix Process System Calls</span></div><div><b><img src="07%3A%20Individual%20Process%20Management.html.resources/F185DD63-7704-4049-A8B3-3C0B2C670DB5.png" height="356" width="908"/><br/></b></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Unix Process Hierarchy</span></div><ul><li><div>Every Unix process (apart from init) has a parent, they may create multiple children via forking <span style="font-weight: bold;">e.g. </span>unix boot structure.</div></li><li><div>Unix processes have their own stack and stack pointer - makes it expensive as you have to store them separately.</div></li><ul><li><div>Single parentless process runs (init)</div></li><li><div>Init reads a file which lists all connected terminals</div></li><li><div>Init forks a login process for each terminal</div></li><li><div>If login process validates user, it forks a shell process</div></li></ul></ul><div><br/></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 85px;"/><col style="width: 432px;"/></colgroup><tbody><tr><td colspan="2" style="width: 517px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Threads: User vs Kernel vs Language</span></td></tr><tr><td style="width: 85px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">User Threads</span></div></td><td style="width: 432px; padding: 8px; border: 1px solid;"><ul><li><div>Supported in user-level library</div></li><li><div>Kernel only knows about processes</div></li><li><div>Schedule by a per-process, user-level scheduler</div></li></ul></td></tr><tr><td style="width: 85px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Kernel Threads</span></div></td><td style="width: 432px; padding: 8px; border: 1px solid;"><ul><li><div>Supported by OS and scheduled by OS scheduler </div></li><li><div>Threads are preemptible by OS - more predictable</div></li><li><div>Supported in almost all modern OS</div></li></ul></td></tr><tr><td style="width: 85px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Language Threads</span></div></td><td style="width: 432px; padding: 8px; border: 1px solid;"><ul><li><div>Available only in particular language environments </div></li><li><div>Might be implemented either as user or kernel threads</div></li></ul></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Advantages of User Threads</span></div><ol><li><div>OS support not required</div></li><li><div>Cheap context switch - order of magnitude is faster than kernel, easy to offer per-app scheduling policies</div></li></ol><div><br/></div><div><span style="font-weight: bold;">Disadvantages of User Threads</span></div><ol><li><div>If thread calls system call that blocks, all other processes are blocked.</div></li><li><div>User threads can’t execute on separate CPUs on multicore. </div></li></ol><div><br/></div></body></html>