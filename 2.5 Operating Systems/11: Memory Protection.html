<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="81.16945648193359"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-11 15:16:03 +0000"/><meta name="latitude" content="52.65316772460938"/><meta name="longitude" content="-1.158833427218628"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-16 10:49:14 +0000"/><title>11: Memory Protection</title></head><body><div><span style="font-weight: bold;">Running multiple jobs</span></div><ul><li><div><span style="font-weight: bold;">Multi-programming: </span>Switches between processes as they become blocked (waiting for I/O).</div></li><li><div><span style="font-weight: bold;">Multi-Tasking: </span>Regularly switch between processes so each appears interactive.</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Simple Protection: Base and Limit</span></div><ul><li><div>Protect processes from each other - for every memory access, enforce a base and limit <span style="font-weight: bold;">i.e. </span>minimum and maximum of address space.</div></li><li><div>Easy to test requested address between set values and simple to switch in software.</div></li><li><div>Easy to relocate registers as well as manage the memory.</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Segmentation</span></div><div><span style="background-color: rgb(255, 255, 255);" title="Page 21"
				/><img src="11%3A%20Memory%20Protection.html.resources/EC6C844F-1566-485D-84D2-0E7F9802A22A.jpg" height="776" width="1038"/><span style="background-color: rgb(255, 255, 255);" title="Page 21"
			/></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 90px;"/><col style="width: 428px;"/></colgroup><tbody><tr><td colspan="2" style="width: 518px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Variable Size Regions</span></div></td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">First Fit</span></div></td><td style="width: 428px; padding: 8px; border: 1px solid;"><div>Always allocate first region of sufficient size found</div></td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Best Fit</span></div></td><td style="width: 428px; padding: 8px; border: 1px solid;"><div>Always allocate smallest memory hole of sufficient size</div></td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Worst Fit</span></div></td><td style="width: 428px; padding: 8px; border: 1px solid;"><div>Always allocate largest memory hole (of sufficient size)</div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Limitations - Variable Size Regions</span></div><ul><li><div><span style="font-weight: bold;">Fragmentation: </span>If we free large area of memory, we may leave a gap in memory which prevents us from storing something larger.</div></li><li><div><span style="font-weight: bold;">Defragmentation: </span>Shuffling memory around to reduce the effects of fragmentation. </div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Variable vs. Fixed Size Schemes</span></div><ul><li><div><span style="font-weight: bold;">External Fragmentation: </span>Variable allocation scheme, give requested amount of memory - space left outside or between allocated memory.</div></li><li><div><span style="font-weight: bold;">Internal Fragmentation: </span>Fixed allocation scheme, give memory in fixed-sized blocks - round to n * block size.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Paging: </span>Reads and writes data from/to secondary storage that is used in primary storage. </div><ul><li><div>Add pages as needed between stack and heap as it is a variable size. </div></li><li><div>Different virtual addresses may map to the same physical frame thus allowing us to have shared memory using pages.</div></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 90px;"/><col style="width: 403px;"/></colgroup><tbody><tr><td colspan="2" style="text-align: center; width: 493px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Where to put Page tables</span></td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Registers</span></div></td><td style="width: 403px; padding: 8px; border: 1px solid;"><div>Fast but limited capacity</div></td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Memory</span></div></td><td style="width: 403px; padding: 8px; border: 1px solid;">Capacity only limited by memory but slow access time</td></tr><tr><td style="width: 90px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Solution</span></div></td><td style="width: 403px; padding: 8px; border: 1px solid;"><div>Use a hybrid method where we maintain cache of page to frame translations (Translation Look-aside Buffer, TLB). Entries are generally flushed when changing process.</div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Page size problem</span></div><ul><li><div>If we were to store the pages with their offset, virtual address and physical address then the size of this table would be 256GB.</div></li><li><div>Instead we are able to store the virtual address only, 32 bit addresses. However, this would mean this is 4MB per process</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Hierarchical / Multi-level Paging: </span>Allows us to increase the number of memory accesses which reduces the speed of every memory reference.</div><ul><li><div>Problem is that the page tables are held in physical memory.</div></li><li><div>Once paging is enabled the code including kernel uses virtual addresses.</div></li><li><div><span style="font-weight: bold;">Self Mapping</span> solves this issue…</div></li></ul><div><img src="11%3A%20Memory%20Protection.html.resources/F576AF44-6113-46D3-98F8-BD8302D59E74.png" height="454" width="720"/><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Self Mapping: </span>Circular reference used to point to the page directory allowing to move back and forth using virtual addresses only by mapping the physical addresses.</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Hashed Page Tables</span></div><div><b><img src="11%3A%20Memory%20Protection.html.resources/FFBCAB07-D926-472B-9A84-E6B42B9D6B9A.png" height="548" width="1040"/><br/></b></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Inverted Page Tables: </span>Page table has only one entry for each frame where one table is used by all processes.</div><ul><li><div>Allows us too search for a process ID and page tuple <span style="font-weight: bold;">i.e. </span>&lt;Process ID, Page&gt; where the page is the located page reference.</div></li></ul><div><br/></div></body></html>