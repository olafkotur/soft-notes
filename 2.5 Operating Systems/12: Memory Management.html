<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.74959564208984"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-12 13:51:25 +0000"/><meta name="latitude" content="52.6397705078125"/><meta name="longitude" content="-1.192668977963685"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-14 07:49:38 +0000"/><title>12: Memory Management</title></head><body><div><span style="font-weight: bold;">Page Fault: </span>Exception given if a process attempts to access a location that is not mapped in its Page Tables.</div><ul><li><div>Processes only are given the entries for the memory it already uses.</div></li><li><div>Essentially an attempt to access memory address through an empty entry.</div></li><li><div>Memory is not always ordered - virtual memory translations usually are so that it makes sense in code but this is usually abstracted.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Demand Paging: </span>Start a process with partial or empty page tables.</div><ul><li><div>Reference to unallocated memory will cause a PAGE FAULT</div></li><li><div>The page fault handler will create new Page table and attaches it to the page directory</div></li><li><div>It will allocate physical memory for frame and retrieves the code or data from the disk.</div></li><li><div>The last instruction will re-rerun which will now succeed.</div></li></ul><div><br/></div><div><img src="12%3A%20Memory%20Management.html.resources/6EC8F03B-A459-40CD-87CE-452DB74D1E18.png" height="684" width="1014"/><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Present Flag: </span>Shows whether there is a valid frame in a virtual address. This is kept in the control section of the 12 bits. </div><div><img src="12%3A%20Memory%20Management.html.resources/8C2088E4-C0EB-4C04-AB00-CB6CC3199D6D.png" height="426" width="986"/><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Dirty Page Flag: </span>Also located in the control section, this flag essentially means that the page has been touched or modified in any way.</div><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 70px;"/><col style="width: 447px;"/></colgroup><tbody><tr><td colspan="2" style="width: 517px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Replacement Process</span></div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 1</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Take page fault</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 2</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Determine free frame available in memory for use - if none identify a victim frame</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 3</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Write new page to disk and then take the last page out</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 4</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Adjust Page tables - mark as not present</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 5</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Read request page from disk into identified frame</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 6</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Adjust page tables - mark new page entry as present</div></td></tr><tr><td style="width: 70px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Step 7</span></div></td><td style="width: 447px; padding: 8px; border: 1px solid;"><div>Restart affected process</div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Speeding up replacement</span></div><ul><li><div>If you keep at least one page free at all times you can skip creating one thus speeding up the process.</div></li><li><div>Keep write queue of likely victims (pages) thus if process tries to access this space again we can rescue it before it does so.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">FIFO vs LRU vs LFU</span></div><ul><li><div>Shouldn’t replace first pages as they are likely to hold key parts of a process including libraries and global variables.</div></li><li><div>First pages are also likely to be frequently accessed pages for the same reason.</div></li><li><div>LRU - least recently used pages means it is safer to replace these are they are not accessed as much.</div></li><li><div>We can track the last access time also in the control information bits.</div></li><li><div>LFU - least frequently used, perhaps an even much safer option?</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Second Chance Algorithm</span></div><ul><li><div>Keep a circular list of current pages allowing us to walk over page tables.</div></li><li><div>If page fault occurs, replace the page and advance the pointer.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Working Set: </span>Amount of memory required by a process in a given time interval.</div><ul><li><div>Each process has a page fault frequency</div></li><ul><li><div>Low: Working set may be too large</div></li><li><div>High: Working set may be too small.</div></li></ul></ul><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">Memory Allocation</span></div><ul><li><div><span style="font-weight: bold;">Equal Allocation: </span>Divide memory equally among n processes.</div></li><li><div><span style="font-weight: bold;">Proportional Allocation: </span>Allocate memory based on the size of the process</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Thrashing: </span>Occurs when process is allocated too few frames and experiences high number of page faults</div><ul><li><div>Affects CPU utilisation due to spending time paging in and out</div></li><li><div>Thus little useful work is carried out during processing.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Memory Zones</span></div><ul><li><div>Some memory may be fast enough for all operations whilst some hardware can only access subsets of memory.</div></li><li><div>We can partition memory into zones only allocating memory from special zone if we have to.</div></li></ul><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">Non-Page Based Allocation</span></div><div><br/></div><div><span style="font-weight: bold;">Buddy Allocation: </span>Each memory area can be split into two buddies and also combined forming the original pair into a larger block.</div><ul><li><div>When we request a specific memory block we repeatedly split until we have the right sized block in terms of 2^n.</div></li><li><div><span style="font-weight: bold;">Fragmentation</span> - must round up all request to 2^n size, this is not a problem for smaller blocks for but produces large overhead in the larger blocks.</div></li></ul><div><img src="12%3A%20Memory%20Management.html.resources/7094CD66-3152-446A-B595-A96DDE4BB116.png" height="432" width="822"/><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Slab Allocation: </span>Allocate memory for group of similar objects in one go - don’t have to be the same type, only similar size.</div><ul><li><div>Provides little fragmentation as there is little wasted space by the objects.</div></li><li><div>The allocation is fast for objects.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Combination: </span>Allocate large areas using buddy allocation and then sub-divide areas into common sizes as slabs.</div><ul><li><div>Objects able to be best allocated based on: </div></li><ul><li><div>Size</div></li><li><div>Memory word or cache alignment</div></li><li><div>Any inter-object spacing to catch write overruns.</div></li></ul></ul><div><br/></div></body></html>