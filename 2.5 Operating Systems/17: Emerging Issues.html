<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.71434783935547"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-18 16:06:24 +0000"/><meta name="latitude" content="52.63964035237146"/><meta name="longitude" content="-1.192958000070401"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-18 17:16:22 +0000"/><title>17: Emerging Issues</title></head><body><div><b>MULTIPLE PROCESSORS</b></div><div><b><br/></b></div><div><b>General Purpose GPU (GPGPU)</b></div><ul><li><div>Often under-utilised even though they are now common</div></li><li><div>Growing interest in use for general processing</div></li><li><div>More OS’ now use GPU for user interfaces</div></li><li><div>Tend to have limited I/O interfaces </div></li><li><div>Good for dense vector and array operations</div></li><li><div>However, need special libraries as they are generally not schedule within the core OS</div></li></ul><div><br/></div><div><br/></div><div><b>Non Uniform Memory Access (NUMA)</b></div><ul><li><div>Memory to Processors access costs can differ</div></li></ul><div><img src="17%3A%20Emerging%20Issues.html.resources/23CF77F0-CC4E-44B4-A246-10ADBD9AA28B.png" height="422" width="850"/>v</div><div><br/></div><div><br/></div><div><b>Multi-Processing</b></div><ul><li><div><b>Symmetric (SMP): </b>Processors considered equal, each processor runs own schedular. Adds complexity of load-balancing and process migration.</div></li><li style=""><div><b>Asymmetric (AMP): </b>Scheduler runs on single processor and coordinates all others, simple and effective. However, will not work for some specialist processors <b>e.g. </b>canny move code from x86 to GPU.</div></li></ul><div><br/></div><div><b><br/></b></div><div><b>Processor Affinity: </b>Allow a processor to run a specific task if that processor has carried the same task before. Increases performance as process can have useful info already cached from the previous run.</div><div><br/></div><div><br/></div><div><b>Interrupts with Multi-Processors</b></div><ul><li><div>Interrupts need direction to appropriate processor</div></li><li><div>If passed / linked to the wrong CPU we must forward requests or move code and data.</div></li><li><div>Creates extra overhead and latency issues and a high cost in NUMA systems (shared memory)</div></li></ul><div><br/></div><div><br/></div><hr/><div><br/></div><div><b>VIRTUALISATION</b></div><div><b><br/></b></div><div><b>Motivation: </b>Many machines under utilised and often idle - not good for server hosting and cloud computing services.</div><div><br/></div><div><b>It’s just a VM</b></div><div><img src="17%3A%20Emerging%20Issues.html.resources/9CD1919F-1AB6-48E5-AA8A-462586BFC70B.png" height="514" width="860"/></div><div><br/></div><div><br/></div><div><b>Para-virtualisation: </b>Modify guest OS to be virtualisation aware - accesses CPU features via function calls. Possible dangers include:</div><ul><li><div>Kernel becoming overly dependent on one VM Monitor and even a specific version.</div></li><li><div>Diverge into separate VM and Native Kernels - is a huge problem if split becomes visible to applications.</div></li></ul><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 93px;"/><col style="width: 425px;"/></colgroup><tbody><tr><td colspan="2" style="text-align: center; width: 518px; padding: 8px; border: 1px solid;"><b>Virtualisation Models</b></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><b>Hosted</b></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Guest OS sits on top of existing OS and drivers.</div><ul><li><div>Inefficient due to access to devices</div></li><li><div>Flexible due to well established set of drivers</div></li></ul></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><b>Hypervisor</b></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Guest on top of minimal kernel - run on dedicated hardware.</div><ul><li><div>Efficient and lightweight solution</div></li><li><div>Host OS restricted to more limited set of drivers</div></li></ul></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><b>Hybrid</b></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Hypervisor and service OS with full driver set.</div><ul><li><div>Lightweight solution with backup of protection and driver support.</div></li></ul></td></tr></tbody></table><div><br/></div></div><div><b>Accessing Memory</b></div><ul><li><div>Can translate guest virtual addresses eventually to host physical address to access memory.</div></li><li><div>Works for CPU based memory access but doesn’t for IO operations.</div></li><li><div><b>Hardware Visualisation: </b>Multiple OSs run on a host share the resources of the hardware.</div></li></ul><div><b><img src="17%3A%20Emerging%20Issues.html.resources/819FCFEE-49DF-487B-B03A-13EA088E2565.png" height="324" width="574"/></b></div><br/></body></html>