<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.71434783935547"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-18 16:06:24 +0000"/><meta name="latitude" content="52.63964035237146"/><meta name="longitude" content="-1.192958000070401"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-13 19:34:40 +0000"/><title>17: Emerging Issues</title></head><body><div><span style="font-weight: bold;">MULTIPLE PROCESSORS</span></div><div><br/></div><div><span style="font-weight: bold;">General Purpose GPU (GPGPU)</span></div><ul><li><div>Often under-utilised even though they are now common</div></li><li><div>Growing interest in use for general processing</div></li><li><div>More OS’ now use GPU for user interfaces</div></li><li><div>Tend to have limited I/O interfaces </div></li><li><div>Good for dense vector and array operations</div></li><li><div>However, need special libraries as they are generally not schedule within the core OS</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Non Uniform Memory Access (NUMA)</span></div><ul><li><div>Memory to Processors access costs can differ</div></li></ul><div><img src="17%3A%20Emerging%20Issues.html.resources/23CF77F0-CC4E-44B4-A246-10ADBD9AA28B.png" height="422" width="850"/>v</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Multi-Processing</span></div><ul><li><div><span style="font-weight: bold;">Symmetric (SMP): </span>Processors considered equal, each processor runs own schedular. Adds complexity of load-balancing and process migration.</div></li><li><div><span style="font-weight: bold;">Asymmetric (AMP): </span>Scheduler runs on single processor and coordinates all others, simple and effective. However, will not work for some specialist processors <span style="font-weight: bold;">e.g. </span>canny move code from x86 to GPU.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Processor Affinity: </span>Allow a processor to run a specific task if that processor has carried the same task before. Increases performance as process can have useful info already cached from the previous run.</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Interrupts with Multi-Processors</span></div><ul><li><div>Interrupts need direction to appropriate processor</div></li><li><div>If passed / linked to the wrong CPU we must forward requests or move code and data.</div></li><li><div>Creates extra overhead and latency issues and a high cost in NUMA systems (shared memory)</div></li></ul><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">VIRTUALISATION</span></div><div><br/></div><div><span style="font-weight: bold;">Motivation: </span>Many machines under utilised and often idle - not good for server hosting and cloud computing services.</div><div><br/></div><div><span style="font-weight: bold;">It’s just a VM</span></div><div><img src="17%3A%20Emerging%20Issues.html.resources/9CD1919F-1AB6-48E5-AA8A-462586BFC70B.png" height="514" width="860"/><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Para-virtualisation: </span>Modify guest OS to be virtualisation aware - accesses CPU features via function calls. Possible dangers include:</div><ul><li><div>Kernel becoming overly dependent on one VM Monitor and even a specific version.</div></li><li><div>Diverge into separate VM and Native Kernels - is a huge problem if split becomes visible to applications.</div></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 93px;"/><col style="width: 425px;"/></colgroup><tbody><tr><td colspan="2" style="text-align: center; width: 518px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Virtualisation Models</span></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Hosted</span></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Guest OS sits on top of existing OS and drivers.</div><ul><li><div>Inefficient due to access to devices</div></li><li><div>Flexible due to well established set of drivers</div></li></ul></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Hypervisor</span></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Guest on top of minimal kernel - run on dedicated hardware.</div><ul><li><div>Efficient and lightweight solution</div></li><li><div>Host OS restricted to more limited set of drivers</div></li></ul></td></tr><tr><td style="width: 93px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Hybrid</span></div></td><td style="width: 425px; padding: 8px; border: 1px solid;"><div>Hypervisor and service OS with full driver set.</div><ul><li><div>Lightweight solution with backup of protection and driver support.</div></li></ul></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Accessing Memory</span></div><ul><li><div>Can translate guest virtual addresses eventually to host physical address to access memory.</div></li><li><div>Works for CPU based memory access but doesn’t for IO operations.</div></li><li><div><span style="font-weight: bold;">Hardware Visualisation: </span>Multiple OSs run on a host share the resources of the hardware.</div></li></ul><div><b><img src="17%3A%20Emerging%20Issues.html.resources/819FCFEE-49DF-487B-B03A-13EA088E2565.png" height="324" width="574"/><br/></b></div><div><br/></div></body></html>