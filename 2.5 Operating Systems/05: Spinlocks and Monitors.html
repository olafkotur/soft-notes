<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.67790222167969"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-10 17:58:35 +0000"/><meta name="latitude" content="52.63970947265625"/><meta name="longitude" content="-1.19271885397027"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-10 18:32:24 +0000"/><title>05: Spinlocks and Monitors</title></head><body><div><span style="font-weight: bold;">Spinlock</span></div><ul><li><div>Each Java object has intrinsic lock <span style="font-weight: bold;">Object.wait( ) </span>and <span style="font-weight: bold;">Object.notify( ) </span></div></li><li><div>Keeps thread active and continuously ’spin’ attempting acquire the lock.</div></li><li><div>Potentially improves threading performance and CPU usage</div></li></ul><div><br/></div><div><span style="background-color: rgb(255, 255, 255);" title="Page 10"
				/><img src="05%3A%20Spinlocks%20and%20Monitors.html.resources/57B42FA4-2444-4D5B-BD3C-6B200DDF483D.jpg" height="668" width="1056"/><span style="background-color: rgb(255, 255, 255);" title="Page 10"
			/></div><div><br/></div><div><span style="font-weight: bold;"><br/></span></div><div><span style="font-weight: bold;">Disabling Interrupts</span></div><ul><li><div>Preemptive context switched only happens when interrupt occurs, could disable interrupts to prevent context switch in critical section.</div></li><li><div>Interrupts might be disabled for long time and clock ticks and I/O events may be missed.</div></li><li><div>Only one clock for any and all critical section thus interrupts will tend to be disabled frequently.</div></li><li><div>Error proneness <b>i.e. </b>forgetting to call release lock.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Machine Instruction</span></div><ul><li><div>Single machine instruction - checks variable value, sets it automatically.</div></li><li><div>Sets variable passed to true and tells if it was true or false before.</div></li><li><div>If two processes perform operation, both set target value to true but only one returns false</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>boolean test_and_set(boolean *target) { </div><div><span>    </span>boolean orig_val = *target; </div><div><span>    </span>*target = TRUE;</div><div><span>    </span>return orig_val;</div><div>}</div></div><div><br/></div><div><br/></div><div><b>Software Only - Peterson’s Algorithm</b></div><ul><li><div>No special hardware needed, only works with two threads as it assumes thread ID are 0 and 1 thus big limitation.</div></li></ul><div><img src="05%3A%20Spinlocks%20and%20Monitors.html.resources/08080D00-0434-4049-996E-CEDA21FB8082.png" height="488" width="850"/></div><div><br/></div><div><br/></div><div><b>Spinlock Performance</b></div><ul><li><div>Atomic read-alter-writer instruction sequence supported by hardware</div></li><li><div>Instructions read a value from memory and write new value atomically</div></li></ul><div><img src="05%3A%20Spinlocks%20and%20Monitors.html.resources/4E6BDDE7-320A-4233-8509-A5B2F0373520.png" height="404" width="992"/><img src="05%3A%20Spinlocks%20and%20Monitors.html.resources/06072316-E7C8-49CB-97D9-A4CB52661704.png" height="338" width="524"/></div><div><br/></div><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 258px;"/><col style="width: 258px;"/></colgroup><tbody><tr><td style="width: 258px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><b>Blocking</b></div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><b>Spinning</b></div></td></tr><tr><td style="width: 258px; padding: 8px; border: 1px solid;">Scheduler blocks threads while they wait. Good for <b>long critical sections</b> but costly if lock is acted by lots of process, includes frequent queue management.<br/></td><td style="width: 258px; padding: 8px; border: 1px solid;">Sit in tight loop until acquisition. Good for <b>short critical sections </b>but costly for long critical sections, avoids queue management.</td></tr></tbody></table><div><b><br/></b></div><div><b>Monitor: </b>Concurrent control construct for synchronisation and scheduling</div></div><ul><li><div>Can perform mutual exclusion</div></li><li><div>Block for certain conditions to become true</div></li><li><div>Notify other threads that conditions are now true</div></li></ul><div><br/></div><div><b>Thundering Herd Problem: </b>When using notifyAll( ) when a lot of processes are sleeping, all threads at once come alive and they all go into action. <b>YEEEET!</b></div><div><b><br/></b></div><div><br/></div></body></html>