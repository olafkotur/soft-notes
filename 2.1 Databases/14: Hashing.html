<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="57.80806732177734"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-26 13:27:02 +0000"/><meta name="latitude" content="54.00811767578125"/><meta name="longitude" content="-2.78449858128148"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-26 14:48:39 +0000"/><title>14: Hashing</title></head><body><div><b>Hash Function: </b>Applied to a hash field to obtain address of disk block containing record.</div><ul><li><div>For most records a single block access is needed to retrieve record</div></li><li><div>Very fast access under certain search conditions</div></li></ul><div><br/></div><div><b><br/></b></div><hr/><div><b><br/></b></div><div><b>Internal Hashing: </b>Used within program whenever group of records is accessed using only one value.</div><ul><li><div>Some languages have this by default <b>e.g. </b>Java</div></li><li><div>Common hash function is to take the value of the field, divide it by the number of slots in table - this is the new index value</div></li><li><div>^ Ensures that all values returned are between 0 and M-1(number of slots), thus valid</div></li><li><div>If value is not an Integer you can convert it <b>e.g. </b>Strings = ASCII values added together</div></li><li><div><b>Collision: </b>No guarantee that no values will not hash to same index, otherwise known as synonyms.</div></li></ul><div><br/></div><div><b><br/></b></div><div><b>Resolving Collisions</b></div><ul><li><div><b>Open Addressing: </b>Find next empty slot until an empty one is found - pretty shit for retrieval as the file does not relate to its hash, also means that it blocks actual hash values for future hash values.</div></li><li><div><b>Multiple Hashing: </b>If the first hash function results in collision use another hash function, can keep using or just use open addressing</div></li><li><div><b>Chaining: </b>Builds a linked list from the expected hash value index and then points to other areas of memory.</div></li></ul><div><b><br/></b></div><div><b><br/></b></div><hr/><div><br/></div><div><b>External Hashing</b></div><ul><li><div>Target address space is made of buckets</div></li><li><div>Bucket is either one disk block or a cluster of contiguous disk blocks</div></li><li><div>Each bucket holds multiple records</div></li><li><div>Hash function maps key into relative bucket number (but never a disk block)</div></li><li><div>Bucket table is maintained in file header which converts bucket number to a disk block address</div></li><li><div><b>Collision: </b>Possible that a bucket is filled and new records are hashed to an already full bucket</div></li></ul><div><img src="14%3A%20Hashing.html.resources/C123D77B-20AD-44F4-8994-1762D68EB72F.png" height="306" width="638"/></div><div><br/></div><div><b>Resolving Collisions</b></div><ul><li><div>Simply adds a bucket as the overflow bucket</div></li><li><div>If the bucket is full it would just add it to the next bucket which could be in a different disk block</div></li><li><div>Can chain these until you have a free bucket</div></li><li><div>However, when retrieving you have to search all buckets until the right value is found.</div></li></ul><div><br/></div><div><b>Deletion</b></div><ul><li><div>Simply remove record from its bucket </div></li><li><div>If bucket has overflow chain we can move one of overflown records into main bucket</div></li><li><div>Must keep track of empty overflow locations</div></li></ul><div><br/></div><div><b>Limitations</b></div><ul><li><div>Searching for records using non-hash field is very expensive as the file is unordered.</div></li><li><div>Modifying a hash field requires moving to a different bucket which requires deletion of old record and new record insertion.</div></li></ul><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><b>Static Hashing: </b>Fixed number of maximum buckets</div><ul><li><div>M = max number of buckets for address space</div></li><li><div>m = max number of records</div></li><li><div>Ties us to fixed and static size of M buckets - canny always predict how much data will be stored</div></li><li><div>Changing M requires new hashing function and record redistribution thus expensive AF.</div></li></ul><div><br/></div><div><b>Dynamic Hashing: </b>Extendible Hashing</div><ul><li><div><b>Global Depth: </b>Number of bits that are in question across the whole scheme</div></li><li><div><b>Local Depth: </b>Number of bits in question within a bucket</div></li></ul><ul><li><div>Allows us to increase and decrease the size.</div></li><li><div>Records are distributed to buckets based on leading bits in their hash values</div></li><li><div>The value of depth can be increased or decreased at any time</div></li></ul><div><img src="14%3A%20Hashing.html.resources/A87C3119-7B7F-40FC-A909-6D237B3A9FE9.png" height="426" width="658"/></div><div><br/></div><div><br/></div><div><b>Benefits of Dynamic</b></div><ul><li><div>Performance does not degrade as file grows</div></li><li><div>No space is allocated for future growth as new buckets can be allocated dynamically</div></li><li><div>Splitting causes minor reorganisation as only records in one bucket are redistributed to two new buckets</div></li></ul><div><br/></div><div><b>Limitations of Dynamic</b></div><ul><li><div>Reorganisation is expensive when directory has to be doubled or halved</div></li><li><div>Two block accesses are required <b>i.e. </b>directory must be searched before accessing the buckets.</div></li></ul><div><br/></div></body></html>