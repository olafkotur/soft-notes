<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="57.73773193359375"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-26 15:58:44 +0000"/><meta name="latitude" content="54.00808715820312"/><meta name="longitude" content="-2.784455460641318"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-26 17:18:28 +0000"/><title>15: Access Routines</title></head><body><div><br/></div><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 603px;"/></colgroup><tbody><tr><td colspan="2" style="width: 733px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Selection</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S1 Linear Search</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div>Retrieve every record in file and test attribute values to satisfy the selection condition</div><ul><li><div>Also known as brute force</div></li><li><div>Have to go through every possible record until correct file is found</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S2 Binary Search</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div>Condition involves equality comparison with key attribute by which file is ordered</div><ul><li><div>Split data in half, determine which half record is in.</div></li><li><div>Known as binary chop </div></li><li><div>Chop until the file is found</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S3 Primary Index / Hashing</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div>Condition involves equality comparison with search field attribute</div><ul><li><div>Retrieve based on the search condition hash value</div></li><li><div>SELECT PName = “Kirk” FROM PERSONNEL</div></li><li><div>A hash function for Kirk will return 3409 thus showing the hash value to go to</div></li><li><div>From there we can get the address space</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S4 Primary Index</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div>Retrieve multiple records, if the condition involves &lt; &lt;=, &gt;=, &gt;</div><ul><li><div>The search field will be the primary key essentially</div></li><li><div>This means that all of the data returned will satisfy the condition</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S5 Clustering Index</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;" />Equality comparison on non-key attribute (can occur more than once</div><ul><li><div>Returns all of the values for a given search field</div></li><li><div>Reason, the search field query would be a non-unique</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S5 Secondary Index B+</span></div></td><td style="width: 603px; padding: 8px; border: 1px solid;"><div>Equality comparison against the key value</div><ul><li><div>Trickle down the tree going in the correct paths</div></li><li><div>If the path satisfies leaf node then go down it, otherwise find another</div></li><li><div>Keep doing this till you find it</div></li></ul></td></tr></tbody></table><div><br/></div></div><div><br/></div><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 599px;"/></colgroup><tbody><tr><td colspan="2" style="width: 729px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><span style="font-weight: bold;">Conjunctive Selection</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">S7 Subset</span></div></td><td style="width: 599px; padding: 8px; border: 1px solid;"><div>If at least one of the conditions are able to use any of the other access routines then do it</div><ul><li><div>This will return a set of candidate records</div></li><li><div>Use brute force on this result</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><b>S8 Composite Index</b></div></td><td style="width: 599px; padding: 8px; border: 1px solid;"><div>If two or more attributes involved in equality conditions appear in composite index then just use the index directly.</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><b>S9 Intersection</b></div></td><td style="width: 599px; padding: 8px; border: 1px solid;"><div>If secondary indexes are available on all the fields involved in equality conditions and the indexes include record pointers, retrieve set of record pointers from each index involved and take the intersection</div></td></tr></tbody></table><div><br/></div></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 598px;"/></colgroup><tbody><tr><td colspan="2" style="width: 728px; padding: 8px; border: 1px solid;"><div style="text-align: center; "><b>Join</b></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><b>J1 Nested</b></div></td><td style="width: 598px; padding: 8px; border: 1px solid;"><div>For every record t in R (outer loop), retrieve every record s from S (inner loop) and test join the condition</div><ul><li><div>As in apply the search condition t[A] = s[B]</div></li><li><div>This is a brute force method</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><b>J2 Access Structure</b></div></td><td style="width: 598px; padding: 8px; border: 1px solid;"><div>If one condition has a index/hash then use it</div><ul><li><div>Retrieve every record from the outer loop</div></li><li><div>Then use the access routine for the inner loop to retrieve it all</div></li><li><div>Eliminates one of the loops hence it is no longer M*N complexity, instead it is M II N</div></li></ul></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><b>J3 Sort-Merge</b></td><td style="width: 598px; padding: 8px; border: 1px solid;"><div>If records of R and S are ordered by the join attributes we can scan the files in order of the join attributes - most efficient join operation</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><b>J4 Hash Join</b></div></td><td style="width: 598px; padding: 8px; border: 1px solid;"><div>R and S are hashed to the same hash file thus in the same bucket</div><ul><li><div>Each bucket is scanned to match the condition</div></li></ul><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><br/></div><div><b>Project: </b>Can get rid of duplicates using two methods: </div><ul><li><div><b>Sort: </b>Sort the result and then eliminate the duplicates.</div></li><li><div><b>Hashing: </b>Hash projected tuple and check it against those that already exist in bucket.</div></li></ul><div><br/></div><div><br/></div></body></html>