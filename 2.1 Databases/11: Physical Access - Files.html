<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.9.1 (457703)"/><meta name="altitude" content="98.86876678466797"/><meta name="author" content="Olaf Kotur"/><meta name="created" content="2019-04-24 13:28:03 +0000"/><meta name="latitude" content="52.63970947265625"/><meta name="longitude" content="-1.192897437631393"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-30 07:47:18 +0000"/><title>11: Physical Access - Files</title></head><body><div><span style="font-weight: bold;">Secondary Storage Device: </span>Devices such as magnetic disks, stored on these because:</div><ol><li><div>Generally too large to fit entirely in main memory</div></li><li><div>Less frequent loss of stored data</div></li><li><div>Cost of storage per unit of data is much less compared to primary storage such as main memory.</div></li></ol><div><br/></div><div><span style="font-weight: bold;">Record: </span>A form of storing data, consists of:</div><ol><li><div>Collection of related data values, each formed of one or more bytes.</div></li><li><div>Each data value corresponds to particular field of record</div></li></ol><div><br/></div><div><span style="font-weight: bold;">Record Type: </span>Collection of field names and their corresponding data types.</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div><span style="font-size: 12px; font-family: Monaco;">struct Employee {</span></div><div><font face="Monaco">    char name[25];</font></div><div><font style="font-family: Monaco;">    char NI_Num[9];</font></div><div><font face="Monaco">    Date </font>dateOfBirth;</div><div>    int salary;</div><div><span style="font-size: 12px; font-family: Monaco;">};</span></div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Binary Large Objects (BLObs): </span>Large unstructured object that represent image, video, audio data or free text.</div><ul><li><div>Typically stored separately from its record in a pool of disk blocks.</div></li><li><div>Instead, a pointer to the BLOb is included in record</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Variable-length records: </span>Different record in file have different sizes in bytes.</div><ul><li><div><span style="font-weight: bold;">Length Difference: </span>All records in file are of same type but vary in length.</div></li><li><div><span style="font-weight: bold;">Repeating Field: </span>One or more fields have multiple values.</div></li><li><div><span style="font-weight: bold;">Optional: </span>Not all fields need to be have data, however can be stored as a pair to ensure length &lt;field name, field value&gt;.</div></li><li><div><span style="font-weight: bold;">Fixed: </span>Can include NULLs and spaces to make variable length records appear to be fixed length but this will waste space nevertheless.</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Record Blocking: </span>Allocation of records to disk blocks</div><ul><li><div><span style="font-weight: bold;">Blocking Factor: </span>Amount of records we can store in a block size.</div></li><li><div><span style="font-weight: bold;">Spanned Records: </span>Store part of record in unused space with pointer to block containing remainder.</div></li><li><div><span style="font-weight: bold;">Un-Spanned Records: </span>Not allowed to cross block boundaries.</div></li></ul><div><img src="11%3A%20Physical%20Access%20-%20Files.html.resources/541F94E2-8AA1-4A7A-A013-E1D22C1D9914.png" height="192" width="812"/><br/></div><div><br/></div><div><br/></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 100px;"/><col style="width: 408px;"/></colgroup><tbody><tr><td colspan="2" style="text-align: center; width: 508px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Allocating File Blocks</span></td></tr><tr><td style="width: 100px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Continuous Allocation</span></td><td style="width: 408px; padding: 8px; border: 1px solid;"><div>File blocks are allocated in consecutive disk blocks</div><div><span style="font-weight: bold;">   </span>+ Very fast reading of whole file </div><div>   -- File expansion is difficult</div></td></tr><tr><td style="width: 100px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Linked Allocation</span></div></td><td style="width: 408px; padding: 8px; border: 1px solid;"><div>Each file block contains pointer to next file block</div><div><span style="font-weight: bold;">   </span>+ File expansion is easy</div><div>   -- Slower reading of file</div></td></tr><tr><td style="width: 100px; padding: 8px; border: 1px solid;"><span style="font-weight: bold;">Clustered Allocation</span></td><td style="width: 408px; padding: 8px; border: 1px solid;"><div>Allocate clusters of consecutive disk blocks and link the clusters using a pointer to the next</div></td></tr><tr><td style="width: 100px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Indexed Allocation</span></div></td><td style="width: 408px; padding: 8px; border: 1px solid;"><div>One or more index blocks contain pointers to actual file blocks.</div><div><span style="font-weight: bold;">   </span>+ Speeds up access to records partway through file</div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">File Header/Descriptor: </span>Contains information needed by programs accessing records in file.</div><ul><li><div>Info used to determine disk addresses of file blocks</div></li><li><div>Record format descriptions <span style="font-weight: bold;">e.g. </span>length, field types etc.</div></li></ul><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 258px;"/><col style="width: 258px;"/></colgroup><tbody><tr><td style="width: 258px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Primary File Organisation</span></div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Secondary File Organisation</span></div></td></tr><tr><td style="width: 258px; padding: 8px; border: 1px solid;"><div>How records of file are physically placed on disk</div></td><td style="width: 258px; padding: 8px; border: 1px solid;"><div>How are the records on file accessed from disk.</div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">Unordered Records (heap files)</span></div><ul><li><div>Records placed in file in order they are inserted - new files at end.</div></li><li><div>Insertion is very efficient as address of last file block is kept in header.</div></li><li><div>Searching for record is very expensive as it requires a linear search.</div></li><li><div>Deletion is searching + rewriting block back to disk AND there is unused space left in disk block.</div></li><li><div><span style="font-weight: bold;">Deletion Marker: </span>Single bit or byte stored, if marked as deleted then searches will not take it into account. Requires reorganisation to reclaim unused space.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Ordered Records</span></div><ul><li><div>Physically order records of file based on values of one of their fields (ordering field or ordering key if unique for each record).</div></li><li><div>Reading records in order defined by a key is highly efficient as no sorting is required.</div></li><li><div>Finding the next record from the current one requires no additional block access.</div></li><li><div>Able to use search conditions in the query.</div></li><li><div>No advantage for random or ordered access based on values of non-ordering fields.</div></li><li><div>Insertion and deletion of records is expensive as records must remain physically ordered - can keep extra unused space in each block but this is also no Gucci.</div></li></ul><div><img src="11%3A%20Physical%20Access%20-%20Files.html.resources/597F518A-6179-46B9-B9B0-6564F642E4A9.png" height="540" width="848"/><br/></div><div><br/></div></body></html>